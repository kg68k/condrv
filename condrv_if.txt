condrv(em).sys Application Programming Interface


* システムコール------------------------------ *

d0.w = $0000
        機能 : バッファリング制御
        入力 : d1.w == 0 : OFF
                    != 0 : ON
        出力 : d0.l = 0
        備考 : 従来からある機能です。システムステータスの再表示は各自で行って下さい。

d0.w = $0010
        機能 : マウス制御(無効)
        入力 : なし
        出力 : d0.l = 0
        備考 : マウスルーチンの削除に伴って無効化してあります。

d0.w = $0020
        機能 : IOCS _KEY_INIT のフック
        入力 : a1.l = 処理アドレス
        出力 : d0.l = 元の設定アドレス
        備考 : IOCS _KEY_INIT が呼び出された時に実行するサブルーチンを登録します。
               IOCS のベクタを変えずに CONDRV.SYS でフックしたルーチン内部から呼び
               出すので、従来の(IOCTRL を使わない)方法による制御を阻害しません。

d0.w = $0021
        機能 : IOCS _KEY_INIT のフック解除
        入力 : a1.l = 現在の処理アドレス
               a2.l = 元の処理アドレス
        出力 : d0.l =  0 : 正常終了
                      -2 : アドレスが異常
        備考 : d0.w = $0020 で登録したサブルーチンを削除します。
               CONDRV.SYS 内部で記憶しているアドレスと a1.l が異なる場合はエラーとなります。

d0.w = $0022
        機能 : IOCS _KEY_INIT の処理アドレス収得
        入力 : なし
        出力 : d0.l = アドレス
        備考 : d0.w = $0020 で登録した最後のサブルーチンのアドレスを返します。

d0.w = $0023
        機能 : バッファリング履歴制御
        入力 : d1.w == 0 : POP
                    != 0 : PUSH
        出力 : d0.l =  0 : 正常終了
                      -2 : スタックが空の時に POP しようとしたか、
                           スタックが満杯の時に PUSH しようとした場合。
        備考 : 現在のバッファリングモードをスタックに待避、または
               最後に待避したモードをスタックから取り出して設定します。
               システムステータスの再表示は各自で行って下さい。
               スタックは32回分の待避が出来る容量があります。
               XCONT PUSH/POP 用に設けた機能なので、他のアプリケーション
               からは使用しないで下さい。

d0.w = $0024
        機能 : バッファリング制御II
        入力 : d1.w == -1 : ON (stop_level--)
                    ==  0 : 現在のレベルを収得する
                    == +1 : OFF(stop_level++)
        出力 : d0.l = 変更後のレベルを返す(0～65535)
                    == -1 : レベルが既に上限/下限に達している
        備考 : ユーザの C-bs によるバッファリングの停止とは無関係に動作する
               第二のバッファリング抑制機能です. 停止レベルが 1 以上の場合
               バッファリングが行われなくなります. ユーザのキー操作で制御
               することは絶対に出来ません.
               アプリケーションが d0.w = $0000 の機能で停止させると、ユーザ
               が C-bs を入力すると再開してしまう不都合があるので、今後は
               こちらを使用するようにして下さい.

d0.w = $ffff
        機能 : バージョン検査
        入力 : なし
        出力 : d0.l == -1 : 純正品
                    == 'e??#' : ?? = 版数(例:'05'), # = 修正版番号(例:' ','a')

d0.w が未定義の数値だった場合は d0.l = -1 を返します。


* 公開ワーク --------------------------------- *

IOCS _KEY_INIT のベクタ-4のアドレスのデータが'hmk*'であれば CONDRV.SYS
は存在し、同-28のアドレスから28バイトが公開ワーク。
ただし、公開されているのは一部の内容だけである。

<○>:  公開ワーク
<×>:非公開ワーク

offset  size
 0(-28) 1.b     <×>起動時のオプション(bit7=1:-j、bit0=1:-f)
                    (bit1=1:BG 対応/sleep モード、xcont で使用するので変更禁止)
 1(-27) 1.b     <×>未使用
 2(-26) 1.w     <×>未使用(オリジナルではペーストのカウンタ)
 4(-24) 1.w     <×>〃     (〃            ペーストのカウンタ初期値)
 6(-22) 1.l     <○>システムコールのアドレス
10(-18) 1.b     <○>空文字列(オリジナルでは非公開、未使用)
11(-17) 1.b     <○>キー操作抑制フラグ(ユーザプログラムで変更可能)
12(-16) 1.l     <○>バッファ書き込みルーチンのアドレス
16(-12) 1.l     <○>ペーストバッファのサイズ
20( -8) 1.l     <○>ペーストバッファのアドレス
24( -4) 1.l     <○>識別子'hmk*'
28(  0) ---     IOCS _KEY_INIT の処理ルーチン

「空文字列」は常に 0(NUL)で、ペーストバッファ書き込み時に一時的に
ペースト開始アドレスとして設定しておく為に用意されている.

また、ペーストバッファのアドレス-8からの4バイトも公開されている。

offset  size
0(-8)   1.l     <○>ペースト開始アドレス(ユーザプログラムで変更可能)
4(-4)   1.l     <×>バックログバッファのアドレス
8( 0)   ?.b     ペーストバッファ(ユーザプログラムで書き込み可能)

なお、バックログバッファのアドレスから計算した値でバッファの初期化を行っては
ならない。内部ワークの初期化も必要で、無理に初期化すると最悪の場合暴走する。


* Condrv System Call Sample $0020 ------------ *

        ....
        lea     (new_iocs_key_init,pc),a1
        moveq   #$20,d0
        jsr     (a0)                            System Call
        lea     (orig_iocs_key_init,pc),a1
        move.l  d0,(a1)
        ....

CHK_0   .macro
        .local  skip
        bne     skip
        addq.l  #4,sp
skip:
        .endm

new_iocs_key_init:
        .ifdef  TYPE1 : 新しい処理を行ってから元の処理を行う場合
                move.l  (orig_iocs_key_init,pc),-(sp)
                CHK_0
                bra     new_iocs_key_init_main
        .else   TYPE2 : 元の処理を行ってから新しい処理を行う場合
                pea     (new_iocs_key_init_main,pc)
                move.l  (orig_iocs_key_init,pc),-(sp)
                CHK_0
                rts
        .endif
new_iocs_key_init_main:
        ....
        rts

orig_iocs_key_init:
        .dc.l   0

* CONDRV.SYS 自体は TYPE1 です。
* CHK_0 マクロは安全の為に一応記述してありますが、別に入れなくてもいいです。
* 一回目のフックの返値は IOCS _KEY_INIT の元の処理アドレスそのものとなります。

* Condrv System Call Sample $0021/$0022 ------ *

        ....
        moveq   #$22,d0
        jsr     (a0)                            System Call
        lea     (new_iocs_key_init,pc),a1
        cmpa.l  d0,a1
        bne     restor_error

*       lea     (new_iocs_key_init,pc),a1
        movea.l (orig_iocs_key_init,pc),a2
        moveq   #$21,d0
        jsr     (a0)                            System Call
*       bmi     restor_error
        ....

* -------------------------------------------- *

[EOF]
